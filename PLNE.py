# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ts-tzsAsPsqNn2_8YAwAN5iFhxGdgRMr
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install gurobipy

import numpy as np  # importing numpy
from gurobipy import Model, GRB, quicksum
import random
import matplotlib.pyplot as plt
import json


class Job:
    def __init__(self, index, task_sequence, release_date, due_date, weight):
        self.index = index
        self.task_sequence = task_sequence
        self.release_date = release_date
        self.due_date = due_date
        self.weight = weight

    def show(self):
        print("Job with index {} task sequence {} release date {} due date {} weight {}\n".format(self.index,
                                                                                                  self.task_sequence,
                                                                                                  self.release_date,
                                                                                                  self.due_date,
                                                                                                  self.weight))


class Task:
    def __init__(self, index, processing_time, machines):
        self.index = index
        self.processing_time = processing_time
        self.machines = machines  # list of machine indices on which this task can be performed

    def show(self):
        print(
            'Task with index {} processing time {} and machines {}\n'.format(self.index, self.processing_time,
                                                                             self.machines))


class Instance:
    def __init__(self, nb_operators, alpha, beta, jobs, tasks, operators):
        self.nb_operators = nb_operators
        self.alpha = alpha  # unit penalty
        self.beta = beta  # tardiness
        self.jobs = jobs
        self.tasks = tasks
        self.operators = operators  # operators[i-1, m-1] = list of operators that can operate task i on machine m

    def nb_jobs(self):
        return len(self.jobs)

    def nb_tasks(self):
        return len(self.tasks)

    def nb_machines(self):
        return np.shape(self.operators)[1]

    def nb_operators(self):
        return self.nb_operators

    def show(self):
        print('Instance with {} operators, unit penalty {}, tadiness {} and \n'.format(self.nb_operators, self.alpha,
                                                                                       self.beta))
        print("Jobs : \n")
        for j in range(self.nb_jobs()):
            self.jobs[j].show()
        print("Tasks: \n")
        for t in range(self.nb_tasks()):
            self.tasks[t].show()
        print("Operators: \n")
        print(operators)


file = open("/Users/pierr/OneDrive/Documents/Pierre-Louis/Ponts/2A GI/Recherche "
            "opérationnelle/sujet_et_instances_projet_REOP22-23/sujet_et_instances_projet_REOP22-23/instances/KIRO"
            "-tiny.json")
data = json.load(file)

parameters_data = data["parameters"]
nb_tasks = parameters_data["size"]["nb_tasks"]
nb_machines = parameters_data["size"]["nb_machines"]
nb_operators = parameters_data["size"]["nb_operators"]
alpha = parameters_data["costs"]["unit_penalty"]
beta = parameters_data["costs"]["tardiness"]
jobs_data = data["jobs"]
jobs = [
    Job(job["job"],
        job["sequence"],
        job["release_date"],
        job["due_date"],
        job["weight"],
        ) for job in jobs_data
]

tasks_data = data["tasks"]
tasks = [
    Task(task["task"],
         task["processing_time"],
         [machine["machine"] for machine in task["machines"]],
         ) for task in tasks_data
]

operators = np.empty((nb_tasks, nb_machines), dtype=object)
for task in tasks_data:
    i = task["task"]
    for machine in task["machines"]:
        m = machine["machine"]
        operator_list = machine["operators"]
        operators[i - 1, m - 1] = operator_list

instance = Instance(nb_operators, alpha, beta, jobs, tasks, operators)


def PNLE1(nb_tasks):  # T le nb de tables; P la capacité par table; I le nb d'invités
    model= Model();
    # Définition des variables
    b = {}  # Starting time for a task
    m = {}  # Machine used for a task
    o = {}  # Operator used for a task
    c = {}  # Time at which task is completed
    B = {}  # Time at which job starts
    C = {}  # Time at which job is completed
    U = {}  # Unit of penalty
    T = {}  # Tardiness
    f = {}  # 1 si bj+pj>=bi O sinon
    g = {}  # 1 si bi>=bj O sinon
    x = {}  # 1 si mi=mj ou oi=oj
    mb = {} # 1 si mi=mj
    ob = {} # 1 si oi=oj
    am = {}  # valeur absolue de mi - mj
    mp = {} # partie positive de mi - mj
    mn = {} # partie negative de mi - mj
    y = {}  # variable utilisée pour calculer am
    ao = {} # valeur absolue de oi - oj
    op = {} # partie positive de oi - oj
    on = {} # partie negative de oi - oj
    z = {}  # variable utilisée pour calculer ao

    g = {} # 1 si bj+pj>=bi 0 sinon
    f = {} # 1 si bi>=bj



    k = {}



    for i in range(1,nb_tasks+1):
        # Par défaut lb=0 et ub=+infini
        b[i] = model.addVar(name="b" + str(i), vtype=GRB.INTEGER)  # Starting time for task i
        c[i] = model.addVar(name="c" + str(i), vtype=GRB.INTEGER)  # Finishing time for task i
        m[i] = model.addVar(name="m" + str(i), vtype=GRB.INTEGER)  # Machine used for task i
        o[i] = model.addVar(name="o" + str(i), vtype=GRB.INTEGER)  # Operator used for task i
        for j in range(1,nb_tasks+1):
            f[i,j] = model.addVar(name="f" + str(i) + str(j), vtype=GRB.BINARY, lb=0, ub=1)
            g[i,j] = model.addVar(name="g" + str(i) + str(j), vtype=GRB.BINARY, lb=0, ub=1)
            x[i,j] = model.addVar(name="x" + str(i) + str(j), vtype=GRB.BINARY, lb=0, ub=1)
            mb[i,j] = model.addVar(name="mb" + str(i) + str(j), vtype=GRB.BINARY, lb=0, ub=1)
            ob[i,j] = model.addVar(name="ob" + str(i) + str(j), vtype=GRB.BINARY, lb=0, ub=1)
            y[i,j] = model.addVar(name="y" + str(i) + str(j), vtype=GRB.INTEGER)
            mp[i,j] = model.addVar(name="mp" + str(i) + str(j), vtype=GRB.INTEGER)
            mn[i,j] = model.addVar(name="mn" + str(i) + str(j), vtype=GRB.INTEGER)
            am[i,j] = model.addVar(name="am" + str(i) + str(j), vtype=GRB.INTEGER)
            z[i,j] = model.addVar(name="z" + str(i) + str(j), vtype=GRB.INTEGER)
            op[i,j] = model.addVar(name="op" + str(i) + str(j), vtype=GRB.INTEGER)
            on[i,j] = model.addVar(name="on" + str(i) + str(j), vtype=GRB.INTEGER)
            ao[i,j] = model.addVar(name="ao" + str(i) + str(j), vtype=GRB.INTEGER)
            g[i,j] = model.addVar(name="g" + str(i) + str(j), vtype=GRB.BINARY)
            f[i,j] = model.addVar(name="f" + str(i) + str(j), vtype=GRB.BINARY)




    for j in range(instance.nb_jobs()):
        B[j] = model.addVar(name="B" + str(j), vtype=GRB.INTEGER)  # Starting time for job i
        C[j] = model.addVar(name="x" + str(j), vtype=GRB.INTEGER)  # Finishing time of work j
        U[j] = model.addVar(name="x" + str(j), vtype=GRB.BINARY, lb=0, ub=1)  # Tardiness of job j
        T[j] = model.addVar(name="x" + str(j), vtype=GRB.INTEGER)  # Unit of penalty for job j


    # Fonction objectif
    model.setObjective(
        quicksum(
            jobs[j].weight * (C[j] + instance.alpha * U[j] + instance.beta * T[j]) for j in range(instance.nb_jobs())),
        GRB.MINIMIZE)

    # Définition des contraintes
    # Contrainte 1
    for i in range(1,nb_tasks+1):
        print(i)
        model.addConstr(c[i] == (b[i] + instance.tasks[i-1].processing_time))



    # Contrainte 2
    for j in range(instance.nb_jobs()):
        model.addConstr(B[j] == b[instance.jobs[j].task_sequence[0]])

    # Contrainte 3
    print(nb_tasks)
    for j in range(instance.nb_jobs()):
        print(instance.jobs[j].task_sequence[-1])
        model.addConstr(C[j] == c[instance.jobs[j].task_sequence[-1]])

    # Contrainte 4
    for j in range(instance.nb_jobs()):
        model.addConstr(B[j] >= instance.jobs[j].release_date)

    # Contrainte 5
    for j in range(instance.nb_jobs()):
      for i in range(1,len(instance.jobs[j].task_sequence)):
        model.addConstr((b[instance.jobs[j].task_sequence[i]]) >= c[instance.jobs[j].task_sequence[i-1]])

    # Contrainte 6
    M=1000000
    for j in range(instance.nb_jobs()):
        model.addConstr(U[j] >= T[j]/M)
        model.addConstr(U[j] <= 1)

    # Contrainte 7
    # Partie 1 coder les x[i][j]
    for i in range(1,nb_tasks+1):
        for j in range(1,nb_tasks+1):
            # Contraintes sur les x[i][j] à partir des mb[i][j] et ob[i][j]
            model.addConstr(x[i,j] <= mb[i,j] + ob[i,j])
            model.addConstr(x[i,j] >= (mb[i,j]+ob[i,j])/2)

            # Contraintes sur les mb[i][j] à partir des y[i][j]
            model.addConstr(1 - mb[i,j] >= am[i,j]/(2*M))
            model.addConstr(1 - mb[i,j] <= am[i,j])
            model.addConstr(m[i] - m[j] == mp[i,j] - mn[i,j])
            model.addConstr(am[i,j] == mp[i,j] + mn[i,j])
            model.addConstr(y[i,j] > (m[i] - m[j])/(2*M))
            model.addConstr(y[i,j] <= (m[i] - m[j]+M) / M)
            model.addConstr(mp[i,j] <= y[i,j]*M)
            model.addConstr(mn[i,j] <= (1-y[i,j]) * M)
            model.addConstr(mn[i,j] >= 0)
            model.addConstr(mp[i,j] >= 0)

            # Contraintes sur les ob[i][j] à partir des z[i][j]
            model.addConstr(1 - ob[i,j] >= ao[i,j] / (2 * M))
            model.addConstr(1 - ob[i][j] <= ao[i,j])
            model.addConstr(o[i] - o[j] == op[i,j] - on[i,j])
            model.addConstr(ao[i,j] == op[i,j] + on[i,j])
            model.addConstr(z[i,j] > (o[i] - o[j]) / (2 * M))
            model.addConstr(z[i,j] <= (o[i] - o[j] + M) / M)
            model.addConstr(op[i,j] <= z[i,j] * M)
            model.addConstr(on[i,j] <= (1 - z[i,j]) * M)
            model.addConstr(on[i,j] >= 0)
            model.addConstr(op[i,j] >= 0)


            # Contraintes sur les bi et les bj
    for i in range(1,nb_tasks+1):
        for j in range(1,nb_tasks+1):
            model.addConstr(b[i]+instance.tasks[i].processing_time+b[j]>=instance.tasks[i].processing_time*f[i,j])
            model.addConstr(b[i]-b[j] <= instance.tasks[i].processing_time*g[i,j])

            # Contraintes sur les f[i][j] et g[i][j]
            model.addConstr(g[i,j] >= (b[i] - b[j])/M)
            model.addConstr(g[i,j] <= (b[i] - b[j]+M) / M)
            model.addConstr(f[i,j] >= (b[j]+instance.tasks[j].processing_time - b[i]) / M)
            model.addConstr(f[i,j] <= (b[j] +instance.tasks[j].processing_time - b[i] + M) / M)
    model.optimize()

    print('Obj: %g' % m.ObjVal)
    return('Obj: %g' % m.ObjVal)

PNLE1(nb_tasks)

'''
    # Contrainte chaque invité est à une table
    for i in range(I):
        m.addConstr(quicksum(x[i, k] for k in range(T)) == 1)
    # Contrainte de capacité des tables
    # Contrainte de parité
    # Contrainte de famille
    for k in range(T):
        m.addConstr(quicksum(x[i, k] for i in range(I)) <= P)
        m.addConstr(quicksum(T * x[i, k] * sexe[i] for i in range(I)) <= T + quicksum(sexe[i] for i in range(I)))
        m.addConstr(quicksum(T * x[i, k] * sexe[i] for i in range(I)) >= - T + quicksum(sexe[i] for i in range(I)))
        m.addConstr(quicksum(T * x[i, k] * famille[i] for i in range(I)) <= T + quicksum(famille[i] for i in range(I)))
        m.addConstr(
            quicksum(T * x[i, k] * famille[i] for i in range(I)) >= - T + quicksum(famille[i] for i in range(I)))
    # Lien entre y et x ?
    # entre z et x
    # entre w et x
    for i in range(I):
        for j in range(I):
            if i != j:
                for k in range(T):
                    # m.addConstr(y[i, j, k] <= (1/2)*(x[i, k]+x[j, k])*abs(sexe[i]-sexe[j]))
                    # m.addConstr(z[i, j, k] <= (1/2)*(x[i, k]+x[j, k])*abs(famille[i]-famille[j]))
                    m.addConstr(w[i, j, k] <= (1 / 2) * (x[i, k] + x[j, k]) * abs(couple[i][j]))
    m.optimize()
    table = []

    for v in x.values():
        if v.X == 1:
            lettre = v.VarName
            l = lettre[1:lettre.find(',')]
            for k in range(T):
                if int(lettre[lettre.find(',') + 1:]) == k:
                    for i in range(I):
                        if int(lettre[1:lettre.find(',')]) == i:
                            table.append([i, k])

    return table
'''''

'''
Exemple de code pour le projet TD log 
def PNLE(sexe, famille, couple, T, P, I):  # T le nb de tables; P la capacité par table; I le nb d'invités
    m = Model();
    # création des variables
    x = {}
    y = {}
    z = {}
    w = {}
    for i in range(I):
        for k in range(T):
            x[i, k] = m.addVar(name="x" + str(i) + "," + str(k), vtype=GRB.INTEGER, lb=0, ub=1)
            for j in range(I):
                y[i, j, k] = m.addVar(vtype=GRB.INTEGER, name="y" + str(i) + str(j) + str(k), lb=0, ub=1)
                z[i, j, k] = m.addVar(vtype=GRB.INTEGER, name="z" + str(i) + str(j) + str(k), lb=0, ub=1)
                w[i, j, k] = m.addVar(vtype=GRB.INTEGER, name="w" + str(i) + str(j) + str(k), lb=0, ub=1)
    # Fonction objectif
    m.setObjective(
        quicksum(y[i, j, k] + z[i, j, k] + 20 * w[i, j, k] for i in range(I) for j in range(I) for k in range(T)),
        GRB.MAXIMIZE)
    # Contrainte chaque invité est à une table
    for i in range(I):
        m.addConstr(quicksum(x[i, k] for k in range(T)) == 1)
    # Contrainte de capacité des tables
    # Contrainte de parité
    # Contrainte de famille
    for k in range(T):
        m.addConstr(quicksum(x[i, k] for i in range(I)) <= P)
        m.addConstr(quicksum(T * x[i, k] * sexe[i] for i in range(I)) <= T + quicksum(sexe[i] for i in range(I)))
        m.addConstr(quicksum(T * x[i, k] * sexe[i] for i in range(I)) >= - T + quicksum(sexe[i] for i in range(I)))
        m.addConstr(quicksum(T * x[i, k] * famille[i] for i in range(I)) <= T + quicksum(famille[i] for i in range(I)))
        m.addConstr(
            quicksum(T * x[i, k] * famille[i] for i in range(I)) >= - T + quicksum(famille[i] for i in range(I)))
    # Lien entre y et x ?
    # entre z et x
    # entre w et x
    for i in range(I):
        for j in range(I):
            if i != j:
                for k in range(T):
                    # m.addConstr(y[i, j, k] <= (1/2)*(x[i, k]+x[j, k])*abs(sexe[i]-sexe[j]))
                    # m.addConstr(z[i, j, k] <= (1/2)*(x[i, k]+x[j, k])*abs(famille[i]-famille[j]))
                    m.addConstr(w[i, j, k] <= (1 / 2) * (x[i, k] + x[j, k]) * abs(couple[i][j]))
    m.optimize()
    table = []

    for v in x.values():
        if v.X == 1:
            lettre = v.VarName
            l = lettre[1:lettre.find(',')]
            for k in range(T):
                if int(lettre[lettre.find(',') + 1:]) == k:
                    for i in range(I):
                        if int(lettre[1:lettre.find(',')]) == i:
                            table.append([i, k])

    return table
'''
